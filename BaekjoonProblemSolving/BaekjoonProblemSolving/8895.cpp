/*
https://www.acmicpc.net/problem/8895

&Title
8895번 - 막대 배치

&Question
높이가 1, 2, ..., n인 막대 n개가 일렬로 
배치되어 있다. 막대를 왼쪽이나 오른쪽에서 보면, 큰 막대가 뒤에있는 
작은 막대를 가리게 된다. 아래와 같이 4개의 막대로 이루어진 
두 배치를 살펴보자.위의 두 배치는 모두 왼쪽에서 봤을 때 
막대가 한 개 보이고, 오른쪽에서 봤을 때는 막대가 두 
개 보인다.막대의 개수 n과 왼쪽에서 봤을 때 보이는 막대의 
개수 l, 오른쪽에서 봤을 때 보이는 막대의 개수 r이 
주어진다. 이 때, 이러한 결과를 만드는 배치의 개수를 구하는 
프로그램을 작성하시오. 

&Input
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 
테스트 케이스는 한 줄로 이루어져 있고, n, l, r이 
주어진다. (1 ≤ l,r ≤ n ≤ 20) 

&Output
각 테스트 케이스 마다, 입력으로 주어진 값에 해당하는 
배치의 수를 출력한다. 

&Example
-input
4
4 1 2
4 1 1
5 2 4
20 2 1

-output
2
0
4
6402373705728000


*/

//발상의 전환 N이1이 증가할때 크기가 N인 제일높은게 추가되는게 아닌,
//가장 낮은 높이인것이 추가된다고 생각해보자.
//이때 추가된것은 (기존의 경우)*N이 된다.
//이중 가장 왼쪽에 추가될경우 N증가, L이 1 증가
//가장 오른쪽에 추가될경우 N증가, R이 1증가
//끝자리가 아닌 경우는 N만 증가한다.
//따라서 dp[i-1][j-1][k](가장 왼쪽인경우) + dp[i-1][j][k-1](가장 오른쪽인 경우) + dp[i-1][j][k]*(N-2) (둘다아닌 경우)

//#define _CRT_SECURE_NO_WARNINGS
//#include <cstdio>
//#include <algorithm>
//using namespace std;
//
//long long dp[21][21][21] = {};
//
//int main() {
//	dp[1][1][1] = 1LL;
//	for (int i = 2; i <= 20; i++) {
//		for (int j = 1; j <= 20; j++) {
//			for (int k = 1; k <= 20; k++)
//				dp[i][j][k] = dp[i - 1][j - 1][k] + dp[i - 1][j][k - 1] + dp[i - 1][j][k] * (i - 2);
//		}
//	}
//
//	int T;
//	scanf("%d", &T);
//	while (T--) {
//		int n, l, r;
//		scanf("%d %d %d", &n, &l, &r);
//		printf("%lld\n", dp[n][l][r]);
//	}
//
//	
//	return 0;
//}
